为什么 char 的范围是 -128～127？
​关键原因：计算机用补码（Two's Complement）存储负数，而补码的数学定义导致负数比正数多一个。​
​1. 8 位二进制能表示多少个数？
8 位二进制共有 2^8 = 256 种可能的组合（从 00000000 到 11111111）。
这些组合需要分配给 ​正数、零、负数。
​2. 补码的规则
补码的定义：

​正数和零：直接存储二进制（和原码相同）。
例如：+1 = 00000001，0 = 00000000。
​负数：先取绝对值的二进制，​按位取反 + 1。
例如：-1 的补码计算：
+1 的二进制 = 00000001
按位取反 = 11111110
加 1 = 11111111（这就是 -1 的补码）
​3. 为什么最小值是 -128？
​​（1）补码的数学特性
补码的设计使得 ​**10000000（二进制）没有对应的正数**：
如果尝试用补码规则解码 10000000：
它是负数（最高位是 1），所以先减 1：10000000 → 01111111
按位取反：01111111 → 10000000（即 128）
加负号：-128
但 +128 超出 8 位有符号范围（最大值是 127），所以 10000000 ​只能表示 -128。
​​（2）范围分配
​正数部分：00000000（0）到 01111111（127）→ ​128 个数
​负数部分：10000000（-128）到 11111111（-1）→ ​128 个数
​总计：128（正数 + 0） + 128（负数） = 256 个数，正好覆盖所有 8 位组合。
​4. 为什么负数比正数多一个？
​0 占用了一个正数位置：
补码中 00000000 表示 0，它不算正数也不算负数，但占用了原本可以表示 +128 的位置。
如果 0 不占用位置，理论上可以表示 -128～+127，但 0 必须存在，所以 +128 无法表示。
​补码的对称性被打破：
数学上，-128 的补码是 10000000，而 +128 需要 9 位（010000000），所以 8 位下只能表示 -128 而不能表示 +128。
​5. 示例验证
二进制	十进制值	说明
01111111	127	最大正数
00000000	0	零
11111111	-1	最大的负数（按补码规则计算）
10000000	-128	最小的负数（无法表示 +128）
尝试用补码计算 10000000：
1. 它是负数，先减 1：10000000 → 01111111
2. 按位取反：01111111 → 10000000（即 128）
3. 加负号：-128
你会发现它只能表示 -128，而 +128 在 8 位下无法存储。
​6. 总结
​8 位有符号 char 的范围是 -128～127，因为：
补码的规则导致 10000000 只能表示 -128，无法表示 +128。
0 占用了一个正数位置，使得正数最大是 127，而负数可以到 -128。
​无符号 char 的范围是 0～255，因为所有 8 位都用来表示正数。
​关键结论
​**-128 存在是因为补码的数学定义**，它没有对应的正数 +128。
​计算机用补码存储负数，使得加减法可以直接用硬件电路计算，无需额外处理符号。
如果你记住 ​​“补码的负数比正数多一个”​，就能理解为什么 char 的最小值是 -128 而不是 -127 了！