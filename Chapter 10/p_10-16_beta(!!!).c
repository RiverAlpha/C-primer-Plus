// 指针的兼容性
#include<stdio.h>
int main(){
    int *pt;
    int (*pa)[3];
    int arr1[2][3] = {{2,4,6},{1,3,5}};
    int arr2[3][2] = {{2,4},{6,8},{1,3}};
    int **p2; //指向指针的指针

    //pt是一个指针，存储的是一个已知的地址（非随机地址），通过解指针，寻找存储的地址的存储单元存储的值
    //这里arr[0][0]是一个值，想要pt指向数组第一个元素，需要将arr1[0][0]的地址赋给pt
    pt = &arr1[0][0];
    printf("arr1 = %p,&arr1[0][0] = %p,arr1[0][0] = %d\n",arr1,&arr1[0][0],arr1[0][0]);
    printf("pt = %p,&pt = %p,*pt = %d\n",pt,&pt,*pt);
    //arr1[0] 类型为int[3] 是一个数组
    pt = arr1[0];
    printf("arr1[0] = %p,&arr1[0] = %p\n",arr1[0],&arr1[0]);
    printf("pt = %p,&pt = %p,*pt = %d\n",pt,&pt,*pt);
    //语义错误
    //&arr[0] 类型是 int (*)[3] 是一个指向一个内涵三个int类型值的数组
    //arr1[0]存储的是arr1[0][0]的地址 
    //&arr1[0] 表示【存储的是arr1[0][0]的地址 】的地址 C语言中赋予该表达类型为int (*)[3]
    //解引用一个地址得到的还是一个地址 那就是二级指针 类比二维数组
    //所以以下表达式错误
    pt = &arr1[0];
    printf("arr1[0] = %p,&arr1[0] = %p\n",arr1[0],&arr1[0]);
    printf("pt = %p,&pt = %p,*pt = %d\n",pt,&pt,*pt);

    // pt = arr1  无效（二级指针赋值给一级指针）

    //都是二级指针
    //都是指向内涵3个int类型元素数组的指针
    pa = arr1;

    //（pa指向内涵3个int类型元素数组的指针,arr2指向内涵2个int类型元素数组的指针）
    //pa = arr2 无效
    
    //都是二级指针
    //且指向的指针都是指向int类型
    p2 = &pt;

    //可以将arr2[0]理解为指向arr2[0][0]的指针   arr2[0]类型为int *
    //但不可以将arr2理解为指向arr2[0][0]的指针  arr2类型为int *[2]

    //合法
    *p2 = arr2[0];

    //不合法
    //p2 为int ** arr2为int *[2]
    // p2 = arr2

    return 0;
}